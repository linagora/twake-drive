import { randomUUID } from 'crypto';
import axios from 'axios';
import { ONLY_OFFICE_SERVER, onlyOfficeConnectivityCheckPeriodMS, onlyOfficeCallbackTimeoutMS } from '@config';
import { PolledThingieValue } from '@/lib/polled-thingie-value';
import { PendingRequestQueue, PendingRequestCallback } from '@/lib/pending-request-matcher';
import logger from '@/lib/logger';
import * as Utils from '@/utils';
import { IHealthProvider, registerHealthProvider } from './health-providers.service';

/** @see https://api.onlyoffice.com/editors/basic */
export enum ErrorCode {
  SUCCESS = 0,
  KEY_MISSING_OR_DOC_NOT_FOUND = 1,
  INVALID_CALLBACK_URL = 2,
  INTERNAL_SERVER_ERROR = 3,
  FORCE_SAVE_BUT_NO_CHANGES_TO_APPLY = 4,
  COMMAND_NOT_CORRECT = 5,
  INVALID_TOKEN = 6,
}

/** Error generated by this connector. Should be string to share field with {@link ErrorCode} */
export enum ConnectorErrorCode {
  CALLBACK_TIMEOUT = 'callback_timeout',
}

/** Return the name of the error code in the `ErrorCode` enum if recognised, or a descript string */
export const ErrorCodeFromValue = (value: number) => Utils.getKeyForValueSafe(value, ErrorCode, 'OnlyOffice.ErrorCode');

/** @see https://api.onlyoffice.com/editors/callback */
export namespace Callback {
  enum ActionType {
    USER_DISCONNECTED = 0,
    USER_CONNECTED = 1,
    USER_INITIATED_FORCE_SAVE = 2,
  }
  export const ActionTypeToString = (value: number) => Utils.getKeyForValueSafe(value, ActionType, 'OnlyOffice.Callback.ActionType');

  interface Action {
    type: ActionType;
    userid: string;
  }

  enum ForceSaveType {
    FROM_COMMAND_SERVICE = 0,
    FORCE_SAVE_BUTTON_CLICKED = 1,
    SERVER_TIMER = 2,
    FORM_SUBMITTED = 3,
  }
  export const ForceSaveTypeToString = (value: number) => Utils.getKeyForValueSafe(value, ForceSaveType, 'OnlyOffice.Callback.ForceSaveType');

  export enum Status {
    BEING_EDITED = 1,
    /** `url` field present with this status */
    READY_FOR_SAVING = 2,
    /** `url` field present with this status */
    ERROR_SAVING = 3,
    CLOSED_WITHOUT_CHANGES = 4,
    /** `url` and `forcesavetype` fields present with this status */
    BEING_EDITED_BUT_IS_SAVED = 6,
    /** `url` and `forcesavetype` fields present with this status */
    ERROR_FORCE_SAVING = 7,
  }
  export const StatusToString = (value: number) => Utils.getKeyForValueSafe(value, Status, 'OnlyOffice.Callback.Status');

  /** Parameters given to the callback by the editing service */
  export interface Parameters {
    key: string;
    status: Status;
    filetype?: string;
    forcesavetype?: ForceSaveType;
    url?: string;
    actions?: Action[];
    users?: string[];
    userdata?: string;
  }
}

/** For error responses from the {@see CommandService} */
export class CommandError extends Error {
  constructor(public readonly errorCode: ErrorCode, req: any, res: any) {
    super(
      `OnlyOffice command service error ${ErrorCodeFromValue(errorCode)} (${errorCode}): Requested ${JSON.stringify(req)} got ${JSON.stringify(res)}`,
    );
  }
}

/**
 * Helpers to define the protocol of the OnlyOffice editor service command API
 * @see https://api.onlyoffice.com/editors/command/
 */
namespace CommandService {
  interface BaseResponse {
    error: ErrorCode;
  }
  interface SuccessResponse extends BaseResponse {
    error: ErrorCode.SUCCESS;
  }
  interface ErrorResponse extends BaseResponse {
    error: Exclude<ErrorCode, ErrorCode.SUCCESS>;
  }

  abstract class BaseRequest<TSuccessResponse extends SuccessResponse> {
    constructor(public readonly c: string) {}

    /** POST this OnlyOffice command, does not check the `error` field of the response */
    async postUnsafe(): Promise<ErrorResponse | TSuccessResponse> {
      logger.silly(`OnlyOffice command ${this.c} sent: ${JSON.stringify(this)}`);
      const result = await axios.post(Utils.joinURL([ONLY_OFFICE_SERVER, 'coauthoring/CommandService.ashx']), this);
      logger.info(`OnlyOffice command ${this.c} response ${result.status}: ${ErrorCodeFromValue(result.data.error)}: ${JSON.stringify(result.data)}`);
      return result.data as ErrorResponse | TSuccessResponse;
    }

    /** POST this request, and return the result, or throws if the `errorCode` returned isn't `ErrorCode.SUCCESS` */
    async post(): Promise<TSuccessResponse> {
      const result = await this.postUnsafe();
      if (result.error === ErrorCode.SUCCESS) return result;
      throw new CommandError(result.error, this, result);
    }
  }

  export namespace Version {
    interface Response extends SuccessResponse {
      version: string;
    }
    export class Request extends BaseRequest<Response> {
      constructor() {
        super('version');
      }
    }
  }

  export namespace ForceSave {
    interface Response extends SuccessResponse {
      key: string;
    }
    export class Request extends BaseRequest<Response> {
      constructor(public readonly key: string, public readonly userdata: string = '') {
        super('forcesave');
      }
    }
  }

  export namespace GetForgotten {
    interface Response extends SuccessResponse {
      key: string;
      url: string;
    }
    export class Request extends BaseRequest<Response> {
      constructor(public readonly key: string) {
        super('getForgotten');
      }
    }
  }

  export namespace GetForgottenList {
    interface Response extends SuccessResponse {
      keys: string[];
    }
    export class Request extends BaseRequest<Response> {
      constructor() {
        super('getForgottenList');
      }
    }
  }

  export namespace DeleteForgotten {
    interface Response extends SuccessResponse {
      key: string;
    }
    export class Request extends BaseRequest<Response> {
      constructor(public readonly key: string) {
        super('deleteForgotten');
      }
    }
  }

  export namespace License {
    export interface Response extends SuccessResponse {
      // @see https://api.onlyoffice.com/editors/command/license
      license: object;
      server: object;
      quota: object;
    }
    export class Request extends BaseRequest<Response> {
      constructor() {
        super('license');
      }
    }
  }

  export namespace Info {
    export type Response = SuccessResponse;
    export class Request extends BaseRequest<Response> {
      constructor(public readonly key: string, public readonly userdata: string = '') {
        super('info');
      }
    }
  }

  export namespace Meta {
    export interface Response extends SuccessResponse {
      key: string;
    }
    export class Request extends BaseRequest<Response> {
      constructor(public readonly key: string, public readonly meta: { title: string }) {
        super('meta');
      }
    }
  }
}

/**
 * This object holds possible outcomes for commands like `info` who's result
 * is sent to the callback instead of replied to the request
 */
class CallbackResponseFromCommand {
  /**
   * If the `info` command returned an error code, this is it, or it can
   * be an internal error to this connector (eg.: timeout waiting for callback).
   * (If the `info` command returned {@link ErrorCode.SUCCESS} then this field will be `undefined`)
   */
  public readonly error: Exclude<ErrorCode, ErrorCode.SUCCESS> | ConnectorErrorCode | undefined;

  public constructor(error: ErrorCode | ConnectorErrorCode, public readonly result?: Callback.Parameters) {
    this.error = error === ErrorCode.SUCCESS ? undefined : error;
  }
}

/**
 * Exposed OnlyOffice command service
 * @see https://api.onlyoffice.com/editors/command/
 */
class OnlyOfficeService implements IHealthProvider {
  private readonly poller: PolledThingieValue<CommandService.License.Response>;
  // Technically the timeout field is from the PendingRequestQueue but avoid 2 classes
  private readonly pendingRequests = new PendingRequestQueue<CallbackResponseFromCommand>(onlyOfficeCallbackTimeoutMS);

  constructor() {
    this.poller = new PolledThingieValue(
      'Connect to Only Office',
      async () => {
        logger.info('Only Office license status');
        return await this.getLicense();
      },
      onlyOfficeConnectivityCheckPeriodMS,
    );
    registerHealthProvider(this);
  }
  /** Get the latest Only Office licence status from polling. If the return is `undefined`
   * it probably means there is a connection issue contacting the OnlyOffice server
   * from the connector.
   */
  public getLatestLicence() {
    return this.poller.latest();
  }

  /**
   * Iterate over all the forgotten files as returned by OnlyOffice, call the processor for each..
   * @param processor Handler to process the forgotten file (available at `url`). If `true` is returned,
   * the file is deleted from the forgotten file list in OnlyOffice. If false is returned, the
   * same forgotten file will reappear in a future batch
   * @returns The number of files processed and deleted
   */
  public async processForgotten(processor: (key: string, url: string) => Promise<boolean>): Promise<number> {
    logger.info(`Begin to process forgotten files in OnlyOffice`);
    //TODO: filter by instance id of the key
    const forgottenFiles = await this.getForgottenList();
    if (forgottenFiles.length === 0) {
      logger.info(`No forgotten files in OnlyOffice`);
      return 0;
    }
    Utils.fisherYattesShuffleInPlace(forgottenFiles);
    logger.info(`Forgotten files found: ${forgottenFiles.length}`);
    let deleted = 0;
    for (const forgottenFileKey of forgottenFiles) {
      const forgottenFileURL = await this.getForgotten(forgottenFileKey);
      logger.info(`Forgotten file about to process: ${JSON.stringify(forgottenFileKey)}`, { url: forgottenFileURL });
      const shouldDelete = await processor(forgottenFileKey, forgottenFileURL);
      if (shouldDelete) {
        logger.info(`Forgotten file about to be deleted: ${JSON.stringify(forgottenFileKey)}`);
        await this.deleteForgotten(forgottenFileKey);
        deleted++;
      }
    }
    return deleted;
  }

  /** Generates and returns a random UUID that has a matching pending task enqueued for */
  private enqueuePendingCallback(key: string, callback: PendingRequestCallback<CallbackResponseFromCommand>): string {
    const userdata = randomUUID();
    this.pendingRequests.enqueue(key, userdata, callback);
    return userdata;
  }

  /** Called by the OnlyOffice controller when the OO document editing services uses our callback */
  async ooCallbackCalled(result: Callback.Parameters) {
    if (!result.userdata) return;
    logger.info('OO Callback pending request response received', result);
    return this.pendingRequests.gotResult(result.key, result.userdata, new CallbackResponseFromCommand(ErrorCode.SUCCESS, result));
  }

  // Note that `async` is important in the functions below. While they avoid the overhead
  // of `await`, the `async` is still required to catch the throw in `.post()`

  /** Return the version string of OnlyOffice */
  async getVersion(): Promise<string> {
    return new CommandService.Version.Request().post().then(response => response.version);
  }
  /** Return the version string of OnlyOffice */
  async getLicense(): Promise<CommandService.License.Response> {
    //TODO: When typing the response more fully, don't return the response object itself as here
    return new CommandService.License.Request().post();
  }

  async getHealthData() {
    return { OO: { license: this.poller.latest() } };
  }

  /**
   * Requests a document status and the list of the identifiers of the users who opened the document for editing.
   * The response will be sent to the callback handler.
   * This method just sends the command. The response from the callback will be ignored if
   * this called by itself
   *
   * *Warning*: returns non succesful error codes instead of throwing errors like the other
   *            methods. This is because the immediate response is likely to be itself usefull
   *            for detecting errors.
   */
  async getInfoUnsafe(key: string, userdata: string): Promise<ErrorCode> {
    return await new CommandService.Info.Request(key, userdata).postUnsafe().then(({ error }) => error);
  }

  /** Send the info command, wait for the callback if warranted, and return the error or callback body */
  async getInfoAndWaitForCallbackUnsafe(key: string): Promise<CallbackResponseFromCommand> {
    // const userdata = randomUUID();
    return new Promise((resolve, reject) => {
      const userdata = this.enqueuePendingCallback(key, async (timeout, result) => {
        // The callback has called, unless timeout = true, or result is undefined (cancelled request)
        return resolve(timeout ? new CallbackResponseFromCommand(ConnectorErrorCode.CALLBACK_TIMEOUT) : result);
      });
      void this.getInfoUnsafe(key, userdata).then(
        response => {
          // The command service responded to the `info` command request
          if (response !== ErrorCode.SUCCESS) return this.pendingRequests.gotResult(key, userdata, new CallbackResponseFromCommand(response));
          // If it succeded, just wait for timeout or resolution by the callback
        },
        error => {
          this.pendingRequests.cancelPending(key, userdata).then(() => reject(error));
        },
      );
    });
  }
  /** Force a save in the editing session key provided. `userdata` will be forwarded to the callback */
  async forceSave(key: string, userdata = ''): Promise<string> {
    return new CommandService.ForceSave.Request(key, userdata).post().then(response => response.key);
  }
  /** Return the keys of all forgotten documents in OnlyOffice's document editing service */
  async getForgottenList(): Promise<string[]> {
    return new CommandService.GetForgottenList.Request().post().then(response => response.keys);
  }
  /** Return the url of a forgotten document specified by its key in OnlyOffice's document editing service */
  async getForgotten(key: string): Promise<string> {
    return new CommandService.GetForgotten.Request(key).post().then(response => response.url);
  }
  /** Delete a forgotten document specified by its key in OnlyOffice's document editing service */
  async deleteForgotten(key: string): Promise<string> {
    return new CommandService.DeleteForgotten.Request(key).post().then(response => response.key);
  }
  /**
   * Updates the meta information of the document for all collaborative editors.
   *
   * That's the official description. It send file renames to OO.
   */
  async meta(key: string, title: string): Promise<string> {
    return new CommandService.Meta.Request(key, { title }).post().then(response => response.key);
  }
}

export default new OnlyOfficeService();
